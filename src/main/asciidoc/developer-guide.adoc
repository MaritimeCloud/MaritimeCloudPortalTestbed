= Maritime Cloud Portal - Developer Guide

== Introduction

== Server architecture

Outline of the architecture...

=== History
It would be a lie to claim that the maritime cloud portal is equipped with a 
clean cut architecture. To understand why, and to assist in future decisions on 
what to change and what to keep, lets start out with a quick trip back in the 
short, yet bumpy road of the portal architecture history. 

In the start there was this idea of one web-application with one server side.
Then came the realization, that maybe this was more of one portal, interfacing 
with two possibly separate services, an "identity registry" and some "service 
registry".

The architecture started out as a layered architecture, with an interface, 
an application, a domain and a persistence layer, just as most traditional 
server applications use to have. However, it had a slight bias towards "ports 
and adapters architecture", focusing more on isolating the domain from the 
other layers than on enforcing the traditional roles of the other layers. Also, 
this was all seasoned with tactical patterns from the domain driven design 
literature, like Entities, Value Objects, Services and Repositories. A little 
later on, the ideas of command and query responsibility segregation were 
introduced, at first as a handmade solution, and quickly thereafter fully 
embracing the existing framework called "Axon". The reason for choosing CQRS 
was that it should be well suited for collaboration solutions with many reads 
and limited write operations. Also, it was the expectation that this 
architecture would yield a more flexible domain model that would be easier to 
modify and extend. The concept of aggregates has also become more explicitly 
visible after the introduction of CQRS not the least due to the annotations 
introduced by the Axon framework. 

=== Modules
Currently there are four high level modules (java packages) in the solution. In 
the future, this might be split out into two to three separate applications 
depending how this fit into the broader architectural picture. One direction to
follow could be to split the solution into two separate micro-services, one for 
each of the bounded contexts of identity management and service registry, if, 
however, one agree that this is in fact a suitable breakdown of the problem 
domain. The current module structure could be seen as an early attempt to move 
into this direction, however, there are still some remaining dependencies that 
reveal that this initiative is far from completed. A first next step in this 
direction would be to introduce multiple separate POM modules, hereby 
indicating more cleanly the separation of the sub-domains. 

Common::
Tools, utilities and tactical framework-like components that are generic enough 
to be placed in a separate module.

Identity Registry::
Module concerned with the identification and authentication of (mainly) users. 
It could be argued that the identity of organizations should also be handled 
from here, however this is not currently the case, mainly out of convenience.

Service Registry::
The Service Registry is concerned with, obviously, services; how they are 
defined, where they are offered and by whom. As a side effect, Organizations 
are also defined here, as is organization memberships. 

Portal::
The portal module itself is mainly gathering everything else needed to deliver 
the services to the web-based client. This is where a login context (security) 
is setup and where (some of) the services are exposed as RESTful resources. 

=== Domain

The implemented part of the Maritime Cloud Portal domain consists of the four 
central concepts: the users, the organizations, the service specifications and 
the services. In addition we have (organization) memberships and aliases.

==== User, Organizations and Memberships

image::user-member-org.png[]
The User may sign up to the system and create organizations. Organizations may 
invite users, and users may request membership of organizations. They both may
choose to revoke a membership, and both must give their concent when the other 
part initiates a membership. 

==== Organizations and Services

image::org-service.png[]
Organizations may create Service Specifications and Service Instances.

==== Services

image::service.png[]
A Service Instance is an actual service offered by an organization and that 
adheres to a certain Service Specification. The Service Specification details 
what a service does and how to interact with this kind of service. The service 
specification may also (somehow) be categorized according to its operational 
qualities (see next section).

==== Operational Service
There is another concept in the domain of the the Maritime Cloud, called 
the "operational service". This is sort of a Categorization of services. 
However, in the solution this has only been implemented as a static list, and 
the mapping of Service Specifications to operational services is done scanning 
the summary part of the specification for the occurrence of an operational 
service ID, also, this mapping is only applied in the REST resource.

////
PNG sources from http://yuml.me/diagram/scruffy/class/draw

// user-member-org.png
[User]<-0..*[Membership]
[Membership]0..*->[Organization]
//http://yuml.me/edit/ff70a2b1

// org-service.png
[Organization]+-0..*>[ServiceInstance]
[Organization]+-0..*>[ServiceSpecification]
[Organization]+-0..*>[OperationalService]
// http://yuml.me/edit/b1933dfa

// service.png (right-to-left)
[ServiceInstance]0..1->[ServiceSpecification]
[ServiceSpecification]0..1->[OperationalService]
// http://yuml.me/edit/83e28665


// Not used yet:
[User]-[note:Aggregate root{bg:wheat}]
[Organization]-[note:Aggregate root{bg:wheat}]
[ServiceSpecification]-[note:Aggregate root{bg:wheat}]
[ServiceInstance]-[note:Aggregate root{bg:wheat}]

[ServiceSpecification]-[OrganizationId]

[OrganizationId]-[Organization]
[OrganizationId]-[ServiceSpecification]
[ServiceSpecification]-[ServiceSpecificationId]
[ServiceInstance]-[OrganizationId]
[ServiceInstance]-[ServiceInstanceId]
[ServiceInstance]-[ServiceSpecificationId]

[ServiceSpecification|+name;+summary;+serviceType]

[ServiceInstance]++-0..*>[Coverage]
////

==== Aggregates

=== CQRS and Event Sourcing
The following sections will outline the CQRS solution and eventually introduce 
the Contract generator tool.

==== Concept
The basic concepts of Command and Query Responsibility Segregation is to split
the traditional single, "cover-all-scenarios" domain model into two separate 
models, one for writing and one for reading. The writing model will focus on
protecting transactional integrity, whereas the reading model will focus on
fast delivery of information. The key to achieve this split is to accept a 
certain level of eventual consistency. Combine this with event sourcing and
you will in return get a system that may both be open for extension and scale 
well. 

=== Axon Framework
The Axon Framework is a framework that provides some of all the building blocks 
that you are likely to need when implementing an event sourced domain model.

=== The flow of commands and events
This section will outline the flow of commands and events from a Command hits the 
RESTful resource and until a response for a view request hits the client. Notice,
however, that this includes two requests from the client: one for the command, 
and one (or more) for the later querying of the result of applying the command. 


image::mcp-command-flow.png[]

===== (1) RESTful facade
When a web client submits a command to the Maritime Cloud Portal it is done in 
terms of a HTTP POST or UPDATE request containing a JSON formatted command. The
command will be submitted against the resource that it addresses (using the 
path) and the type of command will be stated as part of the mime-type. 

The 
"Resource"-classes lives in the packages 
`net.maritimecloud.identityregistry.resource` and 
`net.maritimecloud.portal.resource`.

Once the command hits the targeted resource class, it is unwrapped and parsed 
to a corresponding java-based Command class. Some validation and processing
may happen in between (although more is needed before prime time) checking that 
the user is allowed to perform the action and for instance resolving any 
alias-references and adding resource references from the path to the command.

===== (2) CommandGateway
Once the command is instantiated it is dispatched to the _CommandGateway_. This
is an Axon framework and constitutes the entrance to the CQRS engine. From here 
on the flow is more or less controlled by Axon. The command may be delivered to 
the gateway in two ways: blocking or non-blocking. In the first way, the method
only returns once the command has been handled, in the second way, the method
returns as soon as any command validators has succeeded. Currently, the first
way is used by Maritime Cloud Portal, but this was merely done out of 
coincidence, as this was how the initial trails started out. It is expected that 
the non-blocking way can be used as well, maybe even yielding smoother user 
experience.

Through Axon, it is possible to apply various validators on the incoming 
commands which will be evaluated before a command is dispatched to the Command
Handler. This is not currently used in MCP, but might come in handy in the 
future. Especially the possibility to verify arguments according to annotated
JSRxxx specification could be useful in order to protect against misbehaving 
clients.

===== (3) CommandHandler
The CommandGateway dispatches the command to the registered handler. There can 
only be one handler per Command, and Axon will complaint if more is registered
or if none is found.

The CommandHandler is a method that is annotated with the an Axon annotation. 
A special annotation exist that allows a method in the target aggregate to be act 
as the command handler, hereby skipping the step where the handler look up the
target aggregate and invoke a method on it. 

==== (4)
The target aggregate ...

==== (5)
One or more events are recorded in the repository ... 

==== Commands

==== Command gateway

-- Events
--- Replayable filesystem Repository
-- Sagas (handling the long running processes)
-- Views
--- SpringData repositories and in memory database
- Replays all events on startup to rebuild views (projections)

==== The Contract tool
Defining Command and Event classes can be a repetitive task, and the resulting 
structures has so many similarities that the process simply begs for 
automation. For that reason, and for the convenience of having a single and 
concise description of the interface to the command model, a simpleminded 
tool has been designed that can scan a java interface file, called a 
"Contract" and generate Command and Event classes based on the annotated 
methods that it contains. 

The common generator utility and the corresponding annotations "Command" and 
"Event" can be found in the package "net.maritimecloud.common.cqrs.contract".

Two examples of this contract and generator can be found in the Maritime Cloud 
Portal: ...TODO: insert references here... 
This is also marks an excellent starting point for investigating what behavior 
is offered by the domains.

When running the "Generator" it scans the contract and build the corresponding 
Command and Event classes. The resulting classes are placed in a predefined 
package, usually called "api". This package is placed in the source structure 
which is under version control. The reason for that is a bit of a "Hen and the 
Egg" problem which is solved using a poor mans tactic. The problem is that the 
generator itself cannot be build and run if the source has compile errors. 
Errors, that will obviously be there when initially building the project, 
because the Commands and Events that are likely to be referenced elsewhere in 
the source has not yet been build. Placing the generated classes under version 
control ensures that they are present at compile time, allowing the generator 
to be build and run. But then, what is the gain, if the classes are already 
there, you ask? 
The gain is, that when you want to introduce a new command or event, you can 
specify it as a method in the contract, and then simply run the generator and
be assured that the resulting Command or Event class is implemented according
to the same pattern as all the rest. Another benefit is that you have a single
file that lists all the commands that your model understands, and all the 
events that it emits. Also, the generated classes all has a javadoc "@see" tag
that points back to the source contract, allowing for navigation if your IDE 
supports it.

===== Testing
Notice, that, at least on Netbeans, you can actually also use the Command or 
Event in a unit test in advance of it being defined, as this folder needs not 
be compilable for the generator to build and run. Why is that important, you 
ask? 
Well, because this aligns very well with the modus operandi of writing behavior 
driven tests in advance of your implementation, which you love to do, right? 

===== Refactoring
The drawback is of course the awkward situation when refactoring an existing 
Command or Event. In this case it is recommended to use the IDE's refactoring 
tool to change the Command or Event, and then after the fact, commence the same
changes to the contract.

==== Extending the domain
Extending the behavior of the system is achieved in a series of steps, starting
with deciding the intention of the new feature. From this, a name for the 
corresponding command should be chosen. Given the new command, it may already 
be evident which events will be emitted from such a command, thus, these may
also be ready to be defined in the Contract file. Arguments for the command
and events should be decided. Command arguments usually consist of parameters 
that points out the target aggregate as well as the payload of the command, 
the new value to apply or whatever is needed to perform the intended action.
Likewise, Events will have at least a mandatory identity reference, and
usually will repeat the values from the command. In addition, events may 
contain redundant "convenience values", values that may make the life simpler 
for the consumers of the events, for instance it may provide the name of 
a user, instead of just the user id, hence making a separate lookup  by the 
consumer unnecessary.

When the Contract is in place, it is time to generate the corresponding classes.
From there, the command should be introduced in a "Command Handler", either in
a dedicated "CommandHandler" or embedded directly in the targeted aggregate. 

One thing to keep in mind when implementing the handling method is, that in 
contrast to a traditional Service method, the Command Handler method should 
merely call the targeted aggregate and have it verify, that the intended action 
can in fact take place, that is, validate that the state and state-change is 
valid. It should NOT change any state in this scope. When all seems to be clear, 
the aggregate command method should create and emit the corresponding event, 
signaling that this action has now taken place. Next, the corresponding event 
listener is added to the Aggregate. It's only during handling of the event, that 
changes to the state is applied to the aggregate. This can be a mind-twister at 
first, but try to keep in mind that the "true" state of the aggregate is 
expressed by its sequence of events, and only when replaying the sequence from 
the start to the end will you get to the current state. Hence, all state 
changes must be initiated by events and events only. If you use the Axon 
framework to write unit tests, it will assist you in getting some of these
things right. 

Now, presuming you got to a stage where you have introduced a command; has 
defined a handler; has registered this command handler to the Command Gateway;
has introduced at least one new event; and, if that event causes state changes,
has introduced a listener for that event on the aggregate. Then you still have 
some way to go. First, you probably want to be able to submit that command. And
later on, you probably also wants to be able to see the effect of the command.

In the Maritime Cloud Portal, the first part is handled in the RESTful resources. 
You must decide how and where the new command fit in, and after identifying the 
correct resource, you should add a POST or PUT handler to the suitable path.

Finally, viewing the result of the command may be achieved either from an 
existing view, or it may be necessary to introduce a new view. The view consists
of an Event Listener, an "Entry" kind of a JPA entity that mainly consist of 
the aggregate id and the exact values that fulfill the need of at least one 
client use case, and a corresponding (generic) query repository. The listener 
will, depending on the event, create a new entry or find and update an existing 
entry. Finally, the SpringData-based generic JPA repository interface will 
expose a new tailored query, or maybe the existing generic query will do.

=== Security
- shiro

=== REST interface
- jersey JAXB

=== Spring boot and the micro service

== Client architecture

